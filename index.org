#+TITLE: Solutions for Computation
#+OPTIONS: tex:t
#+LANGUAGE: zh
#+HTML_DOCTYPE: <!DOCTYPE html>
#+SETUPFILE: setup/theme-readtheorg-local.setup
#+AUTHOR: sylsaint
#+EMAIL: mailto:limerary@hotmail.com

#+LINK: gh    https://github.com/
#+LINK: rfc   https://tools.ietf.org/html/
#+LINK: w3    https://w3.org/TR/
#+LINK: wiki  https://en.wikipedia.org/wiki/

#+BEGIN_COMMENT
Each major section of this document is defined in its own file.

You can jump to each file by moving the cursor on an "#+include" line
and typing =C-c '= Note: There is *no requirement* to split, but large
org-mode files can become quite slow to edit, so separate sections help
keeping things fluid...
#+END_COMMENT
** chapter 1
*** M_1 and M_2
    + q_1
    + M_1: {q_2}, M_2: {q_4}
    + M_1: q_1 -> q_2 -> q_3 -> q_1 -> q_1, M_2: q_1 -> q_1 -> q_1 -> q_2 -> q_4
    + M_1: yes, M_2: no
    + M_1: no, M_2: yes
*** formal description
    1. {Q={q_1, q_2, q_3}, E={a, b}, q_1, {q_2}, transition}
       | state | a   | b   |
       | q_1   | q_2 | q_1 |
       | q_2   | q_3 | q_3 |
       | q_3   | q_2 | q_1 |
    2. {Q={q_1, q_2, q_3, q_4}, E={a, b}, q_1, {q_1, q_4}, transition}
       | state | a   | b   |
       | q_1   | q_1 | q_2 |
       | q_2   | q_3 | q_4 |
       | q_3   | q_2 | q_1 |
       | q_4   | q_3 | q_4 |
*** diagram of DFA
[[file:chapter1/1.3.png]]

*** intersection of two languages

    1.

*** complement of language

    1. file:chapter1/1.5.1.png
    2. [[file:chapter1/1.5.2.png]]
    3. file:chapter1/1.5.3.png
    4. [[file:chapter1/1.5.4.png]]
    5. file:chapter1/1.5.5.png
    6. file:chapter1/1.5.6.png
    7. file:chapter1/1.5.7.png
    8. [[file:chapter1/1.5.8.png]]

*** diagram of DFAs

    1. [[file:chapter1/1.6.1.png]]
    2. [[file:chapter1/1.6.2.png]]
    3. [[file:chapter1/1.6.3.png]]
    4. [[file:chapter1/1.6.4.png]]
    5. [[file:chapter1/1.6.5.png]]
    6. [[file:chapter1/1.6.6.png]]
    7. [[file:chapter1/1.6.7.png]]
    8. [[file:chapter1/1.6.8.png]]
    9. [[file:chapter1/1.6.9.png]]
    10. [[file:chapter1/1.6.10.png]]
    11. [[file:chapter1/1.6.11.png]]
    12. [[file:chapter1/1.6.12.png]]
    13. [[file:chapter1/1.6.13.png]]
    14. [[file:chapter1/1.6.14.png]]

*** diagram of NFAs with specified states

    1. [[file:chapter1/1.7.1.png]]
    2. [[file:chapter1/1.7.2.png]]
    3. [[file:chapter1/1.7.3.png]]
    4. [[file:chapter1/1.7.4.png]]
    5. [[file:chapter1/1.7.5.png]]
    6. [[file:chapter1/1.7.6.png]]
    7. [[file:chapter1/1.7.7.png]]
    8. [[file:chapter1/1.7.8.png]]

*** recognize union of languages

    1. [[file:chapter1/1.8.1.png]]
    2. [[file:chapter1/1.8.2.png]]

*** recognize concatenation of languages

    1. [[file:chapter1/1.9.1.png]]
    2. file:chapter1/1.9.2.png

*** recognize start of languages

    1. file:chapter1/1.10.1.png
    2. [[file:chapter1/1.10.2.png]]
    3. [[file:chapter1/1.10.3.png]]

*** NFA convertion

Question: Prove that every NFA can be converted to an equivalent one
that has a single accept state

Answer: Asume the NFA is N = {Q, \Sigma, \delta, q_0, F}, F is the set of final states.
Thus, we can construct a new NFA N^1 = {Q, \Sigma, \delta^1, q_0, F^1}, the represent
is as follows:

1. F^1 = {q_f}

2. \delta^1(q, a) = \delta(q, a), q belongs to Q and q not belong to F

3. \delta^1(q, \epsilon) = \delta(q, \epsilon) U {q_f},         q belongs to F, q_f belongs to F^1

Now, we can prove it in bidirection:

==> w is any string accepted by NFA N, so we can conclude that \delta(w, a) belongs to
F. according the transition function above, w is accepted by NFA N^1.

<== w is any string accepted by NFA N^1, and w = w\epsilon,
according to formula \delta^1(q, \epsilon) = q_f, q = \delta^1(q_0, w) = \delta(q_0, w)
belongs to F, so w is also accepted by NFA N.

*** DFA with five states

It can be descripted by the following:
D = {odd b's followed by even a's}, now the answer is not correct, ignore it!

Answer has been fixed, now it's right.

[[file:chapter1/1.12.png]]

*** 1s separated by odd symbols

First, we should construct a NFA, then convert it to a DFA. this DFA has 7 states, besides, the last three final
states with all other states pointing at them and no one point out, so we can combine them into one final state.

[[file:chapter1/1.13.png]]

*** judgement about closure of language under complement

    1. Show that if M is a DFA that recognizes language B, swapping the accept
       and nonaccept states in M yields a new DFA recognizing the complement of
       B. Conclude that the class of regular languages is closed under complemen

       Answer: Assume any DFA M = {Q, \Sigma, \delta, q_0, F}, after swapping states, we get M_c = {Q, \Sigma, \delta, q_0, F_c},
       F_c = {q | q \in Q - F}. for any w \in \Sigma^* and w \notin F, it will falls in the states of Q - F = F_c, thus,
       we can conclude that M_c accepts the complement of language LM.

       According the conclusion above, any DFA and it's complement are DFAs, all the languages accepted by DFAs are regular
       languages, so regular languages are closed under complement.

    2. Show by giving an example that if M is an NFA that recognizes language
       C, swapping the accept and nonaccept states in M doesnâ€™t necessarily yield
       a new NFA that recognizes the complement of C. Is the class of languages
       recognized by NFAs closed under complement? Explain your answer.

       [[file:chapter1/1.14.png]]

       Origin NFA: accepting language containing at least one 0;

       NFA after swapping: accepting language containing (0+1)^*

       Is the class of languages recognized by NFAs closed under complement? Answer: Yes, any NFA is also a NFA after swapping states,
       because every NFA has an equivalent DFA, so they are all regular languages, thus, languages are closed under complement.

*** closure of RL under the star operation

    [[file:chapter1/1.15.png]]

    The origin accepts the language L = {w | w has (2+3n) 0's and n \in N}. using the construction method proposed by 1.15, it will
    accepts w = 000 \notin L. So, it fails to prove the Theorem 1.49.

*** convert NFA to DFA

    a. [[file:chapter1/1.16.a.png]]
    b. [[file:chapter1/1.16.b.png]]
*** TODO write a program to convert NFA to DFA
